# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zZXSX-R4-ChJ6WuXe9nBQkVZT_Aga6S9
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns

data = pd.read_csv("/content/Mall_Customers.csv")

data

# Gráfico de dispersión para Age y Annual Income
plt.figure(figsize=(10, 6))
sns.scatterplot(data=data, x="Age", y="Annual Income (k$)")
plt.title("Gráfico de dispersión: Age vs Annual Income")
plt.xlabel("Edad")
plt.ylabel("Ingreso Anual (k$)")
plt.show()

# Gráfico de dispersión para Age y Spending Score
plt.figure(figsize=(10, 6))
sns.scatterplot(data=data, x="Age", y="Spending Score (1-100)")
plt.title("Gráfico de dispersión: Age vs Spending Score")
plt.xlabel("Edad")
plt.ylabel("Puntuación de Gasto (1-100)")
plt.show()

# Gráfico de dispersión para Annual Income y Spending Score
plt.figure(figsize=(10, 6))
sns.scatterplot(data=data, x="Annual Income (k$)", y="Spending Score (1-100)")
plt.title("Gráfico de dispersión: Annual Income vs Spending Score")
plt.xlabel("Ingreso Anual (k$)")
plt.ylabel("Puntuación de Gasto (1-100)")
plt.show()

# Seleccionar las columnas deseadas
selected_data = data[["Annual Income (k$)", "Spending Score (1-100)"]]

# Guardar los datos seleccionados en un nuevo archivo CSV
selected_data.to_csv("datos_seleccionados.csv", index=False)

pd.read_csv("/content/datos_seleccionados.csv")

data = pd.read_csv("/content/datos_seleccionados.csv")
# Seleccionar solo las columnas numéricas
numeric_data = data.select_dtypes(include=[np.number])

# Crear un gráfico de dispersión (scatter plot) para cada par de columnas numéricas
pd.plotting.scatter_matrix(numeric_data, figsize=(10, 10))
plt.show()

# Mostrar los tipos de datos de cada columna
data_types = data.dtypes
print(data_types)

#Alternativamente, si quieres convertir múltiples columnas, puedes hacerlo así:
column_names = ["Annual Income (k$)", "Spending Score (1-100)"]
data[column_names] = data[column_names].astype(float)

# Imprimir los primeros registros del conjunto de datos para verificar el cambio
print(data.head())

#me iba a rendir por un monton de problemas que me dio el data set de kaggle pero la buena fuerza bruta nada le gana

import numpy as np

data = [
    [15, 39], [15, 81], [16, 6], [16, 77], [17, 40],
    [17, 76], [18, 6], [18, 94], [19, 3], [19, 72],
    [19, 14], [19, 99], [20, 15], [20, 77], [20, 13],
    [20, 79], [21, 35], [21, 66], [23, 29], [23, 98],
    [24, 35], [24, 73], [25, 5], [25, 73], [28, 14],
    [28, 82], [28, 32], [28, 61], [29, 31], [29, 87],
    [30, 4], [30, 73], [33, 4], [33, 92], [33, 14],
    [33, 81], [34, 17], [34, 73], [37, 26], [37, 75],
    [38, 35], [38, 92], [39, 36], [39, 61], [39, 28],
    [39, 65], [40, 55], [40, 47], [40, 42], [40, 42],
    [42, 52], [42, 60], [43, 54], [43, 60], [43, 45],
    [43, 41], [44, 50], [44, 46], [46, 51], [46, 46],
    [46, 56], [46, 55], [47, 52], [47, 59], [48, 51],
    [48, 59], [48, 50], [48, 48], [48, 59], [48, 47],
    [49, 55], [49, 42], [50, 49], [50, 56], [54, 47],
    [54, 54], [54, 53], [54, 48], [54, 52], [54, 42],
    [54, 51], [54, 55], [54, 41], [54, 44], [54, 57],
    [54, 46], [57, 58], [57, 55], [58, 60], [58, 46],
    [59, 55], [59, 41], [60, 49], [60, 40], [60, 42],
    [60, 52], [60, 47], [60, 50], [61, 42], [61, 49],
    [62, 41], [62, 48], [62, 59], [62, 55], [62, 56],
    [62, 42], [63, 50], [63, 46], [63, 43], [63, 48],
    [63, 52], [63, 54], [64, 42], [64, 46], [65, 48],
    [65, 50], [65, 43], [65, 59], [67, 43], [67, 57],
    [67, 56], [67, 40], [69, 58], [69, 91], [70, 29],
    [70, 77], [71, 35], [71, 95], [71, 11], [71, 75],
    [71, 9], [71, 75], [72, 34], [72, 71], [73, 5],
    [73, 88], [73, 7], [73, 73], [74, 10], [74, 72],
    [75, 5], [75, 93], [76, 40], [76, 87], [77, 12],
    [77, 97], [77, 36], [77, 74], [78, 22], [78, 90],
    [78, 17], [78, 88], [78, 20], [78, 76], [78, 16],
    [78, 89], [78, 1], [78, 78], [78, 1], [78, 73],
    [79, 35], [79, 83], [81, 5], [81, 93], [85, 26],
    [85, 75], [86, 20], [86, 95], [87, 27], [87, 63],
    [87, 13], [87, 75], [87, 10], [87, 92], [88, 13],
    [88, 86], [88, 15], [88, 69], [93, 14], [93, 90],
    [97, 32], [97, 86], [98, 15], [98, 88], [99, 39],
    [99, 97], [101, 24], [101, 68], [103, 17], [103, 85],
    [103, 23], [103, 69], [113, 8], [113, 91], [120, 16],
    [120, 79], [126, 28], [126, 74], [137, 18], [137, 83]
]

# Convierte la lista de listas en un array de NumPy
data_array = np.array(data)

# Selecciona las columnas "Annual Income (k$)" y "Spending Score (1-100)"
selected_columns = data_array[:, [0, 1]]

print(selected_columns)

class KMeansClustering:
  def __init__(self, k=3):
    self.k = k
    self.centroids = None


  @staticmethod
  def euclidean_distance(data_point, centroids):
    return np.sqrt(np.sum((centroids - data_point)**2,axis = 1))


  def fit (self, X,max_iterations = 700):
    self.centroids = np.random.uniform(np.amin(X, axis = 0), np.amax(X, axis=0), size=(self.k, X.shape[1]))

    for _ in range(max_iterations):
      y = []

      for data_point in X:
        distances = KMeansClustering.euclidean_distance(data_point, self.centroids)
        clusters_num = np.argmin(distances)
        y.append(clusters_num)

      y = np.array(y)

      cluster_indices = []

      for i in range(self.k):
        cluster_indices.append(np.argwhere(y == i))

      cluster_centers = []

      for i, indices in enumerate(cluster_indices):
        if len(indices) == 0:
          cluster_centers.append(self.centroids[i])
        else:
          cluster_centers.append(np.mean(X[indices], axis =0)[0])

      if np.max(self.centroids - np.array(cluster_centers))< 0.0001:
        break
      else:
        self.centroids = np.array(cluster_centers)


    return y




random_points =selected_columns

kmeans = KMeansClustering(k=5)
labels = kmeans.fit(random_points)


print(labels)

plt.scatter(random_points[:,0], random_points[:,1], c=labels)
plt.scatter(kmeans.centroids[:,0], kmeans.centroids[:,1], c=range(len(kmeans.centroids)),
            marker = "*", s = 200)

plt.show()

from numpy.random.mtrand import random

random_points =selected_columns

new = [[140, 60]]


random_points


random_points = np.concatenate((random_points, new))


kmeans = KMeansClustering(k=5)
labels = kmeans.fit(random_points)


print(labels)

plt.scatter(random_points[:,0], random_points[:,1], c=labels)
plt.scatter(kmeans.centroids[:,0], kmeans.centroids[:,1], c=range(len(kmeans.centroids)),
            marker = "*", s = 200)

plt.show()

print(labels[-1])

'''
Despues de las 10 horas de dolor y sufrimiento, he logrado algo muy bruto pero
funcional, tuve que recurrir a los medotos de hard coding mas sucios
y disfuncionales que he visto, pero al final, salio un codigo, que aun que por
falta de hiperparametros puede que de algunos errores pero estoy orgulloso de
este codigo aun que esta horrible, falta muchas mejoras, por ejemplo hacer que
los colores siempre esten asociados a un cluster y que pueda nombrarlo, ya que
realmente en este momento aun que imprimima el cluster donde quedo el ultimo
dato agregado, dependemos de la grafica para encontrarlo, la verdad no entendi
del todo las ecuaciones, pero al final todo salio relativamente bien, quisiera
adaptar este codigo con otras funciones o mejor dicho sin tanto hard coding
'''